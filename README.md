# feathers-graphql

[![Build Status](https://travis-ci.org/feathers-x/feathers-graphql.png?branch=master)](https://travis-ci.org/feathers-x/feathers-graphql)
[![Code Climate](https://codeclimate.com/github/feathers-x/feathers-graphql/badges/gpa.svg)](https://codeclimate.com/github/feathers-x/feathers-graphql)
[![Test Coverage](https://codeclimate.com/github/feathers-x/feathers-graphql/badges/coverage.svg)](https://codeclimate.com/github/feathers-x/feathers-graphql/coverage)
[![Dependency Status](https://img.shields.io/david/feathers-x/feathers-graphql.svg?style=flat-square)](https://david-dm.org/feathers-x/feathers-graphql)
[![Download Status](https://img.shields.io/npm/dm/feathers-graphql.svg?style=flat-square)](https://www.npmjs.com/package/feathers-graphql)

> A high performance GraphQL service for SQL and non-SQL databases. Faster than the populate hook.

## Installation

**For now you have to install the repo directly from GitHub, not from npm.**

```
npm install feathers-graphql --save
```

## Introduction

You should understand [why you would want to use GraphQL](https://reactjs.org/blog/2015/05/01/graphql-introduction.html)
and become [familiar with using it.](https://www.graphql.com/guides/)

feathers-graphql is designed for:
- The client specifies what deeply included data it needs.
- Retrieving that data very efficiently.
- Working with both SQL and non-SQL databases.
- Generating most of the code needed to support the database schemas, while allowing customization.

Using feathers-graphql with Feathers services can be **much** faster than using the populate common hook.
- Reads are batched, so if `user` records need to be read for different parts of the query --
perhaps in one place we need all the authors of multiple posts, while in another place we need all the authors of some commments --
just one `user.find({ query: { id: { $in: [...] } } })` is performed rather than a
`user.find({ query: { id: ... } })` for each author.
- Records are also cached, so a `user` record need not be reread.
- You can choose to persist some caches between queries, so reads are not required to prime them at the start of each query.
    - You can choose the maximum size appropriate for each cache to control memory pressure. The least-recently-used records are cleared.
    - A hook is provided for your Feathers services which clears keys from a cache when their records are mutated.

We can illustrate the performance improvement by counting the number of Feathers service reads the example's
[findUser query](./example/docs/find-user.md)
performs:
- Custom code (working very much like the populate common hook): **76 reads.**
- High performance, generated code, the first time it runs: **7 reads.**
- High performance, generated code, subsequent times it runs: **6 reads.**

**The performance improvement may be significant.**

Code is generated for both Feathers services and SQL statements,
driven by decorations which you add to the schema.
You can customize that code and your customizations will persist through subsequent code regenerations.
You will find these decorations are must easier and faster to write
than coding all the required GraphQL resolvers and SQL metadata yourself.

You can choose, when feathers-graphql is configured, whether Feathers services or SQL statements should be used.

## Working Example and Additional Documentation

A full featured example, with a test harness and
[detailed documentation](./example/README.md),
is located in `example/`.

It uses feathers-graphql in 3 different ways:
- GraphQL queries are handled by Feathers services. There is no code generation.
- GraphQL queries are handled by SQL statements. There is no code generation.
- Generate code from the schema. GraphQL queries are handled either by Feathers services or SQL statements.

These 3 steps serve as a gradual introduction of the code generation features available in feathers-graphql,
as well as showing that the repo, with your own code, can be used to do anything that GraphQL is capable of.

## Sample Code

Make the following change in a Feathers app generated by the
[Feathers generator](https://github.com/feathersjs/feathers-cli):
```js
// src/services/index.js
const graphql = require('./graphql/graphql.service.js');
module.exports = function () {
  // ... current lines
  app.configure(graphql);
};
```

Add your schemas, like this one:
```text
# src/services/graphql/schemas/comment-schema.graphqls
type Comment {
  _id: ID!
  uuid: ID!          @feathers(service: "comment", key: "uuid", sqlTable: "Comments", sqlKey: "uuid")
  authorUuid: ID!    @sql(sqlColumn: "author_uuid")
  postUuid: ID!      @sql(sqlColumn: "post_uuid")
  body: String!
  archived: Boolean!
  author: User!      @resolver(template: "persisted", max: 50, keyHere: "authorUuid", keyThere: "uuid")
  likes: [Like!]     @resolver(template: "shareable", keyHere: "uuid", keyThere: "commentUuid", sort: "uuid")
}
 
type Query {
  getComment(query: JSON, params: JSON, key: JSON): Comment   @resolver(template: "feathers-get", schema: "Comment", sort: "uuid")
  findComment(query: JSON, params: JSON): [Comment!]          @resolver(template: "feathers-find", schema: "Comment", sort: "uuid")
}
```

Add SQL configuration information, if SQL statements will be used.
This example is for `sqlite3`.
```js
// config/default.js
const sqlite = require('sqlite');
module.exports = {
  // ...
  graphql: {
    usingSql: false,
 
    sql: {
      dialect: "sqlite3",
      openDb: () => {
        sqlite.open(join(cwd(), 'data', 'sqlite3.db'));
        return sqlite;
      },
      executeSql: sql => sqlite.all(sql),
    }
  }
};
```

Configure the service:
```js
// src/services/graphql/graphql.service.js
const createService = require('feathers-graphql');
const hooks = require('./graphql.hooks');
 
const schemas = require(`./schemas`);
const metadata = require(`./generated-metadata`);
// Needed if Feathers services are used.
const serviceResolvers = require('./service-resolvers');
// Needed if SQL statements are used.
const sqlResolvers = require('./sql-resolvers');
const sqlJoins = require('./sql-joins');
 
module.exports = function(){
  const app = this;
  
  // Needed if SQL statements are used.
  const { usingSql, sql } = app.get('graphql');
  const { dialect, executeSql, openDb } = sql || {};
  
  const options = {
    schemas,
    metadata,
    resolvers: usingSql ? sqlResolvers : serviceResolvers,
    // Needed if SQL statements are used.
    sqlJoins,
    dialect,
    executeSql,
    openDb: usingSql ? openDb : undefined,
    logSql: false,
  };
 
  // Initialize our service with any options it requires.
  const createdService = createService(options);
  app.use('/graphql', createdService);
  
  // Get our initialized service so that we can register hooks and filters
  const service = app.service('/graphql');
  
  service.hooks(hooks);
};
```

Use the code generation module provided:
```js
// src/services/graphql/compile-schemas.js
const { join } = require('path');
const service = require('feathers-graphql');
const userSchema = require(`./schemas`);
 
// Defines paths for generated modules.
const filePaths = {
  metadata: join(__dirname, 'generated-metadata.js'),
  serviceResolvers: join(__dirname, 'service-resolvers', 'generated-service-resolvers.js'),
  sqlJoins: join(__dirname, 'sql-joins', 'generated-sql-joins.js'),
  sqlResolvers: join(__dirname, 'sql-resolvers', 'generated-sql-resolvers.js'),
}
 
service.compile(userSchema, filePaths);
```

Start the Feathers server normally.

## License

Copyright (c) 2017

Licensed under the [MIT license](LICENSE).
